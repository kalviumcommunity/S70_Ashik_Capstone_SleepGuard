"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._convertToOpenAITool = _convertToOpenAITool;
const function_calling_1 = require("@langchain/core/utils/function_calling");
const types_1 = require("@langchain/core/utils/types");
const zod_1 = require("openai/helpers/zod");
const openai_js_1 = require("./openai.cjs");
/**
 * Formats a tool in either OpenAI format, or LangChain structured tool format
 * into an OpenAI tool format. If the tool is already in OpenAI format, return without
 * any changes. If it is in LangChain structured tool format, convert it to OpenAI tool format
 * using OpenAI's `zodFunction` util, falling back to `convertToOpenAIFunction` if the parameters
 * returned from the `zodFunction` util are not defined.
 *
 * @param {BindToolsInput} tool The tool to convert to an OpenAI tool.
 * @param {Object} [fields] Additional fields to add to the OpenAI tool.
 * @returns {ToolDefinition} The inputted tool in OpenAI tool format.
 */
function _convertToOpenAITool(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
tool, fields) {
    let toolDef;
    if ((0, function_calling_1.isLangChainTool)(tool)) {
        // FIXME: This is a hack to use OpenAI's native zodFunction util
        // since their json schema standard is not always compatible with
        // the schemas produced by zod. Ideally, we should be using the
        // `zodFunction` util always, but that can only happen when OpenAI
        // supports zod v4.
        if ((0, types_1.isZodSchemaV3)(tool.schema)) {
            toolDef = (0, zod_1.zodFunction)({
                name: tool.name,
                parameters: tool.schema,
                description: tool.description,
            });
        }
        else {
            toolDef = (0, openai_js_1.formatToOpenAITool)(tool);
        }
    }
    else {
        toolDef = tool;
    }
    if (fields?.strict !== undefined) {
        toolDef.function.strict = fields.strict;
    }
    return toolDef;
}
